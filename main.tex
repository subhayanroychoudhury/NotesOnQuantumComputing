\documentclass[12pt,oneside]{book}
%\geometry{bindingoffset=0cm}
%\documentclass[prl,aps, 12pt]{revtex4}
%\documentclass[1pt]{revtex4}%{article} \usepackage{amssymb}
\providecommand{\ei}[1]{\color{red}[#1]\color{black}}

\renewcommand{\thesection}{\arabic{section}}
\renewcommand{\thesubsection}{\arabic{subsection}}

\pagestyle{plain} \textwidth=16.5cm \oddsidemargin=0cm \textheight=23cm
\topmargin=-1.25cm

\renewcommand{\baselinestretch}{1.0}


\usepackage{mdframed}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsmath}
\newcommand\numberthis{\addtocounter{equation}{1}\tag{\theequation}}
%\usepackage[fleqn]%{amsmath}
%\usepackage{caption}
%\usepackage{subcaption}
\usepackage{color}
%\usepackage{xcolor}
\usepackage[dvipsnames]{xcolor}
\usepackage{slantsc}
\usepackage{float}
\graphicspath{{./FIG_FINALI/}}
\usepackage{bbold}
\usepackage[caption=false]{subfig}
\usepackage{array}
\usepackage{lipsum}
%\floatstyle{boxed}
%\restylefloat{figure}
\usepackage{braket}
%\usepackage{breqn}
\usepackage{scrextend}
\usepackage{changepage}
\setlength\multlinegap{0pt}
\captionsetup[subfigure]{labelformat=empty}
\usepackage{hyperref}
\hypersetup{backref,pdfpagemode=FullScreen,colorlinks=true,allcolors=blue}
\usepackage{leftidx}
\newcommand{\rededit}[1]{\textcolor{red}{#1}}
\newcommand{\greenedit}[1]{\textcolor{green}{#1}}
\newcommand{\blueedit}[1]{\textcolor{blue}{#1}}

\usepackage{mathtools}
\DeclarePairedDelimiter\brac{\langle}{\rvert}
\DeclarePairedDelimiter\cket{\lvert}{\rangle}

\DeclareMathOperator*{\argmin}{arg\,min}
\title{Quantum Computing Primer for Electronic-Structure}
\author{Subhayan Roychoudhury\\ The Molecular Foundry\\ Lawrence Berkeley National Laboratory}
\date{}
%\affil{LBNL}


\begin{document}

\maketitle

\subsection*{Electronic Structure Theory and the Problem of Scaling}

Any general single-particle state $\ket{\phi}$ can be expressed with respect to position vectors (eigenvectors of the position operator) $\ket{\mathbf{r}}$ as
\begin{align*}
    \ket{\phi} &{}= \int d \mathbf{r} \ket{\mathbf{r}}\braket{\mathbf{r}|\phi}\\
    &{} = \int d\mathbf{r} \phi(\mathbf{r})\ket{\mathbf{r}}, \numberthis
\end{align*}
where we have defined
\begin{align}
    \phi(\mathbf{r})= \braket{\mathbf{r}|\phi}.
\end{align}

For the sake of computational feasibility, we need to work with a discrete set of points within a real space grid. Then, we need to replace the integral with a sum as

\begin{align}\label{OneP_Expansion}
    \ket{\phi} = \sum_{i=1}^M \phi_i \ket{\mathbf{r}_i},
\end{align}
where $M$ denotes the total number of grid points, $\ket{\mathbf{r}_i}$ is the position-vector associated with the $i$-th grid point, and 
\begin{align}
    \phi_i=\braket{\mathbf{r}_i|\phi}.
\end{align}

Eq.~\ref{OneP_Expansion} shows that, in this representation, our basis set $\{\ket{\mathbf{r}_1}, \ket{\mathbf{r}_2},\hdots, \ket{\mathbf{r}_M}\}$ has $M$ number of basis vectors. What happens if, instead of a single particle, we need to describe a two-particle state within the same grid? Now our basis set becomes something like
\begin{align*}
    \{\ket{\mathbf{r}_1\mathbf{r}_1}, \ket{\mathbf{r}_1\mathbf{r}_2} , \hdots , \ket{\mathbf{r}_1\mathbf{r}_M}, \ket{\mathbf{r}_2\mathbf{r}_1} , \ket{\mathbf{r}_2\mathbf{r}_2}, \hdots , \ket{\mathbf{r}_2\mathbf{r}_M}, \hdots , \ket{\mathbf{r}_M\mathbf{r}_1}, \ket{\mathbf{r}_M\mathbf{r}_2}, \hdots , \ket{\mathbf{r}_M\mathbf{r}_M}\},
\end{align*}
where 
\begin{align*}
\ket{\mathbf{r}_i \mathbf{r}_j} = \ket{\mathbf{r}_i}\otimes\ket{\mathbf{r}_j}.
\end{align*}

Thus, we now have $M^2$ basis vectors in our set. Generalizing to an $N$-particle system, we will need $M^N$ number of basis functions. This is an example of exponential scaling with respect to the number of particles.

Now, if the particles are consideration are electrons then a couple of additional points need to be taken into account.
\begin{enumerate}
    \item Electrons have an additional \textit{spin} degree of freedom, which, for a single particle, requires two basis vectors (we will use $\ket{\uparrow}$ and $\ket{\downarrow}$ to denote them). So, the single-electron basis set should be modified to 
    \begin{align*}
        \{\ket{\mathbf{r}_1}\otimes\ket{\uparrow}, \ket{\mathbf{r}_1}\otimes\ket{\downarrow}, \ket{\mathbf{r}_2}\otimes\ket{\uparrow}, \ket{\mathbf{r}_2}\otimes\ket{\downarrow},\hdots, \ket{\mathbf{r}_M}\otimes\ket{\uparrow}, \ket{\mathbf{r}_M}\otimes\ket{\downarrow}\}
    \end{align*}
    This has $2M$ basis vectors.  We shall call them spin-orbitals in the position basis. By extension, for $N$-particles, we will need $(2M)^N$ basis vectors. We will use the notation $\ket{\mathbf{r}_i^\alpha}$ to denote $\ket{\mathbf{r}_i}\otimes\ket{\alpha}$, for $\alpha \in \{\uparrow,\downarrow\}$.
    \item Electrons are indistinguishable particles with wavefunctions that are antisymmetric with respect to an exchange of any two electrons. This implies, for example, that
    \begin{align}
        \ket{\mathbf{r}_i^\alpha\mathbf{r}_j^\beta} = -\ket{\mathbf{r}_j^\beta\mathbf{r}_i^\alpha},
    \end{align}
    and therefore, we do not need to consider them separately when we construct our basis set. We can, in fact, combine them into the so-called Slater determinants.

    This also implies that
\begin{align}
\ket{\mathbf{r}_i^\alpha\mathbf{r}_i^\alpha}=-\ket{\mathbf{r}_i^\alpha\mathbf{r}_i^\alpha}=\ket{0}.
\end{align}

\end{enumerate}

Therefore, from our basis set, we can discard any vector in which the same spin-orbital is occupied by multiple electrons. These considerations will reduce the number of vectors required for our $N$-particle basis set. Any basis vector that we need to include in our new basis set can now be uniquely defined by specifying which spin-orbitals are occupied and which ones are empty (since no spin-orbital can have multiple occupancy and since, thanks to indistinguishability, we do not care which electron is in which orbital). Thus, each basis vector corresponds to choosing $N$ number of occupied orbitals from a total number of $2M$. Therefore, instead of $(2M)^N$, now the number of basis-vectors in our set should be $_{2M}C_N$ (the binomial coefficient \textit{$2M$ choose $N$}). Let us find out what these basis vectors should look like.

If there are $M$ number of spin-orbitals, then any such basis vector (Slater determinant) can be written as
\begin{align}\label{SD_OccupationRepresentation}
    \mathrm{SD}=\ket{j_{M-1}j_{M-2}\hdots j_1 j_0},
\end{align}
where for any $i=0,\hdots,M-1$, the value of $j_i$ can be either 0 or 1. In this convention, $j_i=0$ and $j_i=1$ will indicate, respectively, that the $(i+1)$-th spin-orbital is empty and occupied. Since each spin-orbital can only have two possible occupancies (0 or 1), the number of possible Slater determinants can not exceed $2^M$. However, if the total number of electrons is known to be $N$, then we know that every Slater determinant must have exactly $N$ number of occupied orbitals. Then, as mentioned earlier, the possible number of Slater determinants boils down to $_MC_N$, which, for any $N$, can never exceed $2^M$.

Let us take a concrete example. If there are 2 electrons in our system (like in a hydrogen molecule), then, the representation of an arbitrary electronic state on a $10 \times 10 \times 10$ real space grid will require $_{2000}C_2$ i.e, 1999000 basis vectors. Consequently, we need to store 1999000 number of coefficients if we want to store this state (written as a linear combination of the basis vectors) on a computer. Assuming each coefficient requires a byte of storage, we will need slightly less than 2 MB. 

If there are 42 electrons in our system (like in a benzene molecule), then the number of basis vectors is $_{2000}C_{42}$. This has the order of $10^{87}$. Therefore, the number of bytes required to store all the coefficients will exceed the estimated number of atoms in the universe!

For practical computation, this poses a serious problem in terms of scaling. On a conventional computer, the increment in memory is linear with the increment in the number of storage units. If you double the number of bits, you get twice as much memory. However, for $N$ and $M$ of practical interest, the scaling of $_{M}C_N$  with respect to $N$ is substantially higher. Thus, in practice, if we really want to store all the necessary coefficients on a memory-device, we need a device whose capacity (with respect to the number of storage units) scales \textit{at least} as quickly as $_{M}C_N$. This is exactly where a quantum computer can help.


%Now, the state of a qubit, the unit of information of a quantum computer, resides in a 2-dimensional Hilbert space and thereby, requires two basis vectors for its description. Let us choose a set of orthonormal basis vectors in this Hilbert space and denote them by $\ket{0}$ and $\ket{1}$. Naturally, an arbitrary state of $n$ qubits is expressible as a linear-combination of $2^n$ basis vectors. Thus, the dimension of the relevant Hilbert space, and consequently the storage capacity increases exponentially with the number of qubits.


How, then, can we represent a general many-electron state, written as a linear combination of $_MC_N$ Slater determinants like the one shown in Eq.~\ref{SD_OccupationRepresentation}, with the help of a quantum computer? %Note that every basis 


%We can now easily represent the aforementioned Slater determinant with qubits. In a quantum-representation using qubits, we can adapt a convention whereby, the $i$-th qubit being in state $\ket{1}$ will indicate that the $(i+1)$-th spin-orbital is occupied while the state $\ket{0}$ for the qubit will indicate an unoccupied $(i+1)$-th spin-orbital. 


    
    %It suffices to combine them into a single basis-vector $\ket{\mathbf{r}_i^\alpha\mathbf{r}_j^\beta} - \ket{\mathbf{r}_j^\beta\mathbf{r}_i^\alpha}$.
    
    %A two-electron state $\ket{\Phi} = C_1 \ket{\mathbf{r}_i^\alpha\mathbf{r}_j^\beta} + C_2 \ket{\mathbf{r}_j^\beta\mathbf{r}_i^\alpha} + \hdots$ can be written simply as $\ket{\Phi} = (C_1-C_2) \ket{\mathbf{r}_i^\alpha\mathbf{r}_j^\beta}+\hdots$

\subsection*{The Qubit}

For a quantum computer, the unit of information is a qubit. The state of a single qubit resides in a 2-dimensional vector space. Naturally, any basis-set of this space contains two basis vectors. Let us choose a set where the two orthogonal basis vectors are denoted by $\ket{0}$ and $\ket{1}$. Thus, any general vector 
\begin{align}\label{Eq1}
    \ket{a}=a_0\ket{0}+a_1\ket{1}
\end{align}
can be expressed in matrix-form as $\begin{pmatrix}
        a_0\\
        a_1
    \end{pmatrix}$.

Naturally, the basis-vectors $\ket{0}$ and $\ket{1}$ themselves will be written as
$\begin{pmatrix}
        1\\
        0
    \end{pmatrix}$ and $\begin{pmatrix}
        0\\
        1
    \end{pmatrix}$, respectively.

A tensor product of $\ket{a}$ and $\ket{b}=b_0\ket{0}+b_1\ket{1}$ is then given by

\begin{align}\label{Eq2}
    \ket{ab}=\ket{a}\otimes\ket{b}=a_0b_0 \ket{0}\otimes\ket{0} + a_0b_1 \ket{0}\otimes\ket{1} +a_1b_0 \ket{1}\otimes\ket{0} + a_1b_1\ket{1}\otimes\ket{1}.
\end{align}
$\ket{ab}$ resides in a 4-dimensional space which is the tensor-product space of the two aforementioned vector spaces (i.e., one which hosts $\ket{a}$ and one which hosts $\ket{b}$). If we choose to use $\{\ket{0}\otimes\ket{0} , \ket{0}\otimes\ket{1}, \ket{1}\otimes\ket{0}, \ket{1}\otimes\ket{1}\}$ as the basis-set of this space, then, in matrix form, the vector $\ket{ab}$ can be expressed as $\begin{pmatrix}
    a_0b_0\\
    a_0b_1\\
    a_1b_0\\
    a_1b_1
\end{pmatrix}.$

For example, the two-qubit state $\ket{01}$ can be written as $\begin{pmatrix}
    0\\
    1\\
    0\\
    0
\end{pmatrix}$

This notion can be generalized to more than 2 qubits in a straightforward manner. Continuing the convention introduced in Eq.~\ref{Eq1} and~\ref{Eq2}, for the $2^n$ dimensional vector space of $n$ qubits, we will choose the basis set
\begin{align*}
\{\ket{0,0,\hdots,0,0} , \ket{0,0,\hdots,0,1} , \ket{0,0,\hdots,1,0}, \ket{0,0,\hdots,1,1},\hdots ,\ket{1,1,\hdots,1,1} \}.
\end{align*}
Each basis vector contains $n$ terms, each of which can be either 0 or 1. The basis vectors are ordered in such a way that, for each vector, the rightmost term changes between every consecutive vector. The next (to the left) term remains unchanged for two consecutive vectors and then changes. Continuing in this fashion, it is easy to see that the leftmost term remains unchanged at 0 for the first $2^{n-1}$ basis vectors and then stays fixed at 1 for the rest of the vectors. Such a basis set will be referred to as a computational basis set for $n$ qubits.

\subsection*{Many-electron States : a Qubit-based Representation}

From the discussion presented above, we can see that any computational basis-vector of $M$ qubits can be written as

\begin{align}\label{M_qubit_basis}
    \ket{B} = \ket{q_{M-1}q_{M-2}\hdots q_1 q_0},
\end{align}
where, for any $i=0,\hdots,M-1$, the value of $q_i$ can be either 0 or 1. It is easy to notice the resemblance between Eq.~\ref{M_qubit_basis}, i.e., a basis-vector of the $M$-qubit Hilbert space and Eq.~\ref{SD_OccupationRepresentation}, a basis-vector for a many-electron system with $M$ spin-orbitals. Therefore, in order to represent an arbitrary many-electron state using qubits, we can adopt a convention whereby, the $i$-th qubit being in state $\ket{1}$ will indicate that the $(i+1)$-th spin-orbital is occupied while the state $\ket{0}$ for the qubit will indicate an unoccupied $(i+1)$-th spin-orbital. Then, any general many-electron state of any number of electrons ($<M$), expressible as a linear-combination of Slater determinants (Eq.~\ref{SD_OccupationRepresentation}) composed of $M$ spin-orbitals, can be represented by some general $M$-qubit state constructed as a linear-combination of the computational basis-vectors (Eq.~\ref{M_qubit_basis}).  

Being able to merely represent a many-electrons states with the help of qubits is not enough. Typically, we would be interested in \textit{solving} an electronic-structure problem such as finding a specific eigenstate of a given operator, finding the evolution of a given state with time, etc. To this end, we will typically need the ability to apply operators (for example, the Hamiltonian or the time-evolution operator) on the many-electron states. In the context of quantum computation, this, naturally, means that we need operators for the qubit space. 

\subsection*{Quantum Gates}

In the context of quantum-circuits, an $N$-qubit operator is essentially an $N$-qubit gate that changes an $N$-qubit quantum state from some initial state $\ket{I}$ to some final state $\ket{F}$.

Naturally, an operator in an $N$-dimensional space can be uniquely defined by specifying its actions on the basis functions (which are $N$ in number) of any basis set of that space. Working with the choice of basis set introduced earlier, the Hadamard gate $\hat{H}$ for the 1-qubit space can be defined as
\begin{align*}\label{Hadamard}
    \hat{H}\ket{0} &{}= \frac{1}{\sqrt{2}}\left(\ket{0}+\ket{1}\right) = \ket{+}\\
    \hat{H}\ket{1} &{}= \frac{1}{\sqrt{2}}\left(\ket{0}-\ket{1}\right) = \ket{-}\numberthis
\end{align*}
The orthonormality of $\{\ket{0},\ket{1}\}$ implies that
\begin{align*}
    \braket{0|\hat{H}|0}=\frac{1}{\sqrt{2}}, \hspace{1cm} \braket{0|\hat{H}|1}=\frac{1}{\sqrt{2}}, \hspace{1cm} \braket{1|\hat{H}|0}=\frac{1}{\sqrt{2}}, \hspace{1cm}
    \braket{1|\hat{H}|1}=-\frac{1}{\sqrt{2}}.
\end{align*}
Therefore, with respect to the aforementioned basis set, $\hat{H}$ can be written in matrix form as
\begin{align}
    \frac{1}{\sqrt{2}}\begin{pmatrix}
        1 & 1\\ 1 & -1
    \end{pmatrix}
\end{align}
Another 1-qubit gate is the Pauli gate $\hat{X}$ whose operations are given by
\begin{align*}
    \hat{X}\ket{0} = \ket{1} \hspace{0.5cm} \mathrm{and} \hspace{0.5cm} \hat{X}\ket{1}=\ket{0},
\end{align*}
indicating a matrix representation of $\begin{pmatrix}
    0 & 1\\ 1 & 0
\end{pmatrix}$.
A tensor-product of $N$ number of single-qubit operators (each operator associated with a 2-dimensional vector space) is an operator acting on $N$ qubits (associated with a $2^N$ dimensional vector space). With this in mind, let us construct a simple 2-qubit operator from $\hat{X}$ and $\hat{H}$ such that its operation on the state $\ket{ab}$ (see Eq.~\ref{Eq2}) follows
\begin{align}
\hat{XH}\left(\ket{ab}\right)&{}=\left(\hat{X}\ket{a}\right)\otimes\left(\hat{H}\ket{b}\right)\\
&{}=\left(a_0\ket{1}+a_1\ket{0}\right) \otimes \frac{1}{\sqrt{2}} \left(b_0\ket{+}+b_1\ket{-}\right)
\end{align}
Note that the final state after operation of $\hat{XH}$ can be written as a simple tensor-product of two single-qubit states. Thus, after the operation, the second qubit will be in the state $\left(a_0\ket{1}+a_1\ket{0}\right)$ and the first qubit will be in the state $\frac{1}{\sqrt{2}} \left(b_0\ket{+}+b_1\ket{-}\right)$ with a normalization factor of $\frac{1}{\sqrt{2}}$. Thus, the final state is \textbf{not entangled}. This is not surprising, given that the 2-qubit operator $\hat{XH}$ itself is a simple tensor-product of 2 single-qubit operators.

Let us see an example where this is no longer true. 

A controlled gate acts on a 2-qubit state in such a way that, if the left (control) qubit is in state $\ket{0}$, then it performs an identity operation ($\hat{I}$) on the right (target) qubit. However, if the control qubit is in state $\ket{1}$, then the controlled gate will perform a predefined operation on the target qubit. A controlled NOT (CNOT) gate, for which the predefined operation is a Pauli $\hat{X}$ operation, is a well-known example. Thus,

\begin{align*}
    \hat{\mathrm{CNOT}}\ket{00} &{}= \ket{0} \otimes \left(\hat{I}\ket{0}\right)= \ket{00}\\
    \hat{\mathrm{CNOT}}\ket{01} &{}= \ket{0} \otimes \left(\hat{I}\ket{1}\right) = \ket{01}\\
    \hat{\mathrm{CNOT}}\ket{10} &{}= \ket{1} \otimes \left(\hat{X}\ket{0}\right) = \ket{11}\\
    \hat{\mathrm{CNOT}}\ket{11} &{}=  \ket{1} \otimes \left(\hat{X}\ket{1}\right) = \ket{10},\\
\end{align*}
which indicates a matrix form of $\begin{pmatrix}
    1 & 0 & 0 & 0\\ 0 & 1 & 0 & 0\\0 & 0 & 0 & 1\\ 0 & 0 & 1 & 0
\end{pmatrix}$.

Acting on the 2-qubit state $\ket{+0}$, this will produce
\begin{align*}
    \hat{\mathrm{CNOT}} \ket{+0} &{}= \frac{1}{\sqrt{2}} \hat{\mathrm{CNOT}} \ket{00} + \frac{1}{\sqrt{2}} \hat{\mathrm{CNOT}} \ket{10}\\
    &{}= \frac{1}{\sqrt{2}} \left(\ket{00}+\ket{11}\right).
\end{align*}
This can not be written as a tensor product of 2 single-qubit states. If we measure the state of the first qubit (in this context, when I say ``measure the state'' of a qubit, what I mean is ``measure the observable corresponding to the operator $\hat{Z}$, for which the eigenvectors are $\ket{0}$ and $\ket{1}$) and get, for example, the eigenvalue corresponding to $\ket{1}$, then we know immediately that the entire 2-qubit system must have collapsed to the state $\ket{11}$. Therefore, if we measure the state of the second qubit immediately, we are guaranteed to get $\ket{0}$. Thus, in the state $\hat{\mathrm{CNOT}}\ket{0+}$, the two qubits are entangled! Under these circumstances, there is no such thing as ``state of the first qubit'' or ``state of the second qubit''.

The controlled rotation CROT gate is another example of a contolled gate. This gate performs a rotation operation $\hat{U}_\theta$ by a predefined angle $\theta$ such that
\begin{align*}   \hat{U}_\theta\ket{\psi}=e^{i\theta}\ket{\psi}
\end{align*}
on the target qubit, if the control qubit is $\ket{1}$.

Let us operate this on the 2-qubit state $$\frac{1}{\sqrt{2}}\left(\ket{0}+\ket{1}\right)\otimes\ket{1} = \frac{1}{\sqrt{2}}\left(\ket{01}+\ket{11}\right)$$. This should produce
\begin{align*}
    \frac{1}{\sqrt{2}}\left(\ket{01}+\exp^{i\theta}\ket{11}\right) = \frac{1}{\sqrt{2}} \left(\ket{0}+\exp^{i\theta}\ket{1}\right)\otimes\ket{1}
\end{align*}.
Interestingly, the operation has altered the state of the control qubit from $\frac{1}{\sqrt{2}}\left(\ket{0}+\ket{1}\right)$ to $\frac{1}{\sqrt{2}}\left(\ket{0}+\exp^{i\theta}\ket{1}\right)$, leaving the state of the target qubit intact at $\ket{1}$. In other words, a rotation was essentially applied to the control qubit, even though the rotation operator $\hat{U}_\theta$ acted only on the target qubit. The result of the phase-rotation of the target qubit is effectively kicked back onto the control qubit. This effect is called \textbf{phase kickback}.
Now we will use this effect to construct a quantum circuit that can solve a crucial problem, namely that of finding the discreet Fourier transform.

A periodic function $f(x)$ with a period of $l$ can be written as a linear combination of its Fourier components as
\begin{align}\label{Fourier1}
    f(x)=\frac{1}{\sqrt{l}}\sum_{k=-\infty}^{+\infty} \tilde{f}(k) e^{-2\pi i\frac{kx}{l}},
\end{align}
where $\tilde{f}(k)$ is given by
\begin{align}
    \tilde{f}(k) = \frac{1}{\sqrt{l}}\int_0^l f(x) e^{2\pi i \frac{xk}{l}} dx.
\end{align}
Discretizing the problem, the discreet Fourier transform of a sequence of $N$ complex numbers $\{f(0),f(1),\hdots,f(N-1)\}$ (if we assume that the sequence repeats itself after an interval of $N$, we can compare the elements of this sequence with the values of $f(x)$ from Eq.~\ref{Fourier1} at a discrete set of points) can be defined as
\begin{align}\label{Fourier_tilde_expansion}
    \tilde{f}(k) = \frac{1}{\sqrt{N}} \sum_{j=0}^{N-1} f(j) e^{2\pi i \frac{jk}{N}}
\end{align}

We would want the Quantum Fourier Transform (QFT) operator $\hat{U}_{\rm{QFT}}$ to transform a vector with expansion-coefficients $\{f(0),f(1),\hdots,f(N-1)\}$ with respect to the computational basis-set into a vector with coefficients $\{\tilde{f}(0),\tilde{f}(1),\hdots,\tilde{f}(N-1)\}$. In mathematical terms:

\begin{align}\label{QFT_1}
    \hat{U}_{\rm{QFT}} \left(\sum_{k=0}^{N-1} f(k)\ket{k}\right) = \sum_{k=0}^{N-1}\tilde{f}(k)\ket{k},
\end{align}

where $\ket{k}$ is the $k$-th vectors of the computational basis set. Notably, the basis set contains $N$ number of basis vectors. Therefore, this $N$-dimensional vector space is associated with $n=log_2(N)$ qubits. Taking inner product of both sides of Eq.~\ref{QFT_1} with $\bra{j}$ and summing over $j$,

\begin{align*}
    \sum_{j=0}^{N-1}\sum_{k=0}^{N-1} f(k)\braket{j|\hat{U}_\mathrm{QFT}|k} &{}=  \sum_{j=0}^{N-1}\sum_{k=0}^{N-1} \tilde{f}(k)\delta_{j,k}\\
    &{}=\sum_{j=0}^{N-1}\tilde{f}(j)\\
    &{}=\frac{1}{\sqrt{N}} \sum_{j=0}^{N-1}\left(\sum_{k=0}^{N-1} f(k) e^{2\pi i \frac{kj}{N}}\right)
\end{align*}
where, in the third equality we have used the expansion of $\tilde{f}(j)$ in accordance with Eq.~\ref{Fourier_tilde_expansion}. The above equation implies
\begin{align*}
    \braket{j|\hat{U}_\mathrm{QFT}|k} &{}= \frac{1}{\sqrt{N}} e^{2\pi i \frac{kj}{N}},
\end{align*}
i.e.,
\begin{align*}
    \hat{U}_\mathrm{QFT} = \frac{1}{\sqrt{N}} \sum_{l=0}^{N-1}\sum_{k=0}^{N-1} e^{2\pi i \frac{kl}{N}} \ket{k}\bra{l}
\end{align*}
Now, we will try to express
\begin{align}\label{QFT_2}
    \hat{U}_\mathrm{QFT}\ket{j} &{}=\frac{1}{\sqrt{N}} \sum_{k=0}^{N-1}e^{2\pi ij\frac{k}{N}}\ket{k}.
\end{align}
as a tensor-product of $n$ number of single-qubit states. At this point, it is necessary to express the integer $k$ in terms of its binary representation. If $k$ can be written in binary form as $$k_{n-1}k_{n-2}\hdots k_0 \hspace{2cm} \textrm{ where } k_i \in \{0,1\} \forall i=0,\hdots,n-1,$$
where $k_0$ is the least significant bit, then
\begin{align*}
    k=k_{n-1}2^{n-1}+k_{n-2}2^{n-2}+\hdots+k_02^0.
\end{align*}
Therefore,
\begin{align*}\label{EqBinaryExpansion}
    \frac{k}{N}=\frac{k}{2^n} = \sum_{t=0}^{n-1} \frac{k_t}{2^{n-t}}.\numberthis
\end{align*}
Plugging this expression back into Eq.~\ref{QFT_2}, the following equation is obtained:
\begin{align*}\label{QFT_main}
    \hat{U}_\mathrm{QFT}\ket{j} &{}= \frac{1}{\sqrt{N}} \sum_{k=0}^{N-1} e^{2\pi ij \left( \sum_{t=0}^{n-1} \frac{k_t}{2^{n-t}} \right)}\ket{k}\\
    &{} = \frac{1}{\sqrt{N}} \sum_{k=0}^{N-1} \left(\prod_{t=0}^{n-1} e^{2\pi ij \frac{k_t}{2^{n-t}}}\right) \ket{k}\\
    &{} = \frac{1}{\sqrt{N}} \sum_{k_{n-1}=0}^1 \hdots \sum_{k_1=0}^1\sum_{k_0=0}^1 \left( e^{2\pi ij \frac{k_{n-1}}{2}} \ket{k_{n-1}}\right)\otimes \hdots \otimes \left( e^{2\pi ij \frac{k_1}{2^{n-1}}} \ket{k_1}\right) \otimes \left( e^{2\pi ij \frac{k_0}{2^n}} \ket{k_0}\right)\\
    &{} = \frac{1}{\sqrt{N}} \left(\sum_{k_{n-1}=0}^1 \left( e^{2\pi ij \frac{k_{n-1}}{2}} \ket{k_{n-1}}\right) \right) \otimes \hdots \otimes \left(\sum_{k_1=0}^1 e^{2\pi ij \frac{k_1}{2^{n-1}}} \ket{k_1}\right) \otimes \left(\sum_{k_0=0}^1 e^{2\pi ij \frac{k_0}{2^n}} \ket{k_0}\right)\\
    &{} = \frac{1}{\sqrt{N}} \left(\ket{0} + e^{\frac{2\pi ij}{2}}\ket{1}\right) \otimes \hdots \otimes \left( \ket{0} + e^{\frac{2\pi i j}{2^{n-1}}}\ket{1} \right)\otimes \left(\ket{0}+e^{\frac{2\pi i j}{2^n}}\ket{1}\right)\numberthis
\end{align*}
where, in the third line, we have expressed the $k$-th computational basis vectors as a tensor product of single-qubit basis vectors $$\ket{k}=\ket{k_{n-1}}\otimes\hdots\otimes\ket{k_0}.$$ This lets us express the sum over $k$ (i.e., over all computational basis functions of the $2^n$ dimensional space) in the second line as individual sums over each constituent qubit (as shown in line 3):
\begin{align*}
    \sum_{k=0}^{N-1} \rightarrow \sum_{k_{n-1}=0}^1 \hdots \sum_{k_0=0}^1
\end{align*}

Now we are ready to show that, if the basis-vector $\ket{j}$ is fed into the input of the quantum circuit shown in Fig.~\ref{QFT_circuit} in such a way that the bottommost (topmost) qubit corresponds to the least (most) significant bit, then the transformed state shown in the RHS of Eq.~\ref{QFT_main} is obtained as the output. This circuit contains the Hadamard gate $\hat{H}$ (see Eq.~\ref{Hadamard}) and the controlled rotation $\hat{\mathrm{CROT}}$ gate which we redefine (in a slightly different way) below. If the control qubit is $\ket{0}$, the $\hat{\mathrm{CROT}}_k$ gate performs, as expected, an identity operation on the target qubit. On the other hand, if the control qubit is $\ket{1}$, then a $\hat{R}_k$ operation is performed on the target qubit $\ket{T}$ such that
\begin{align*}
\hat{R}_k\ket{T}=e^{\frac{2\pi i T}{2^k}}\ket{T}
\end{align*}

In our circuit diagram, the two-qubit operation $\hat{\mathrm{CROT}}_k$ is shown by the construction of Fig.~\ref{Fig.CROT_k} where the black dot indicates the operation on the control qubit and the boxed $\hat{R}_k$ indicates the (conditional) rotation operation on the target qubit.

\begin{figure}
    \centering
\includegraphics[width=0.99\textwidth]{QFT_diagram.pdf}
    \caption{Circuit for performing quantum Fourier transform}
    \label{QFT_circuit}
\end{figure}

Now let us take a close look at Fig.~\ref{QFT_circuit}.

\begin{figure}
    \centering   \includegraphics[width=0.5\textwidth]{CROT_gate.png}
    \caption{The $\hat{\mathrm{CROT}_k}$ gate}
    \label{Fig.CROT_k}
\end{figure}

\begin{enumerate}
    \item At the input point (point 1), we have the state $$\ket{j_{n-1} j_{n-2}\hdots j_1 j_0}.$$
    Remember that this is the $j$-th computational basis vector and so the qubits represent the integer $j$ in binary form.
    \item Then a Hadamard gate acts on the topmost qubit, leaving the others intact. Consequently, at point 2 we have 
    \begin{align*}
        \left(\hat{H}\ket{j_{n-1}}\right)\otimes\ket{j_{n-2}\hdots j_1 j_0} = \frac{1}{\sqrt{2}}\left(\ket{0}+e^{\frac{2\pi i j_{n-1}}{2}}\ket{1}\right)\otimes \ket{j_{n-2}\hdots j_1 j_0}
    \end{align*}
    \item Next a controlled rotation $\hat{\mathrm{CROT}}_2$ is applied on the topmost target qubit with the qubit below it serving as the control qubit. The resulting state at point 3 is
    \begin{align*}
\hat{\mathrm{CROT}}_2\left(\ket{0}\otimes\ket{j_{n-2}}+e^{\pi i j_{n-1}}\ket{1}\otimes\ket{j_{n-2}}\right)\otimes \frac{1}{\sqrt{2}}\ket{j_{n-3}\hdots j_0}
    \end{align*}
    Note from the circuit diagram that, of the two qubits involved in the $\hat{R}_2$ operation, the state $\ket{j_{n-2}}$ acts as the control qubit. Note that $$\hat{R}_2\ket{0}=e^{\frac{2\pi i.0}{2^2}}\ket{0}=\ket{0},$$
    and therefore, 
    $$\hat{\mathrm{CROT}}_2\left(\ket{0}\otimes\ket{j_{n-2}}\right) = \ket{0}\otimes\ket{j_{n-2}}.$$
    What about $\hat{\mathrm{CROT}}_2 \ket{1}\otimes\ket{j_{n-2}}$?
    If $\ket{j_{n-2}}=\ket{0}$, then obviously the state remains intact:
    \begin{align*}
        \hat{\mathrm{CROT}}_2 \ket{1}\otimes\ket{j_{n-2}} &{}= \ket{1}\otimes\ket{j_{n-2}}\\
        &{} = e^{\frac{2\pi ij_{n-2}}{2^2}}\ket{1}\otimes\ket{j_{n-2}}
    \end{align*}
    
    If $\ket{j_{n-2}}=\ket{1}$ then
    \begin{align*}
        \hat{\mathrm{CROT}}_2 \ket{1}\otimes\ket{j_{n-2}} &{} = e^{\frac{2\pi i.1}{2^2}}\ket{1}\otimes\ket{j_{n-2}}\\
        &{} = e^{\frac{2\pi ij_{n-2}}{2^2}}\ket{1}\otimes\ket{j_{n-2}}
    \end{align*}
    
    Then the state at point 3 simplifies to
    \begin{align*}
       &{} \left(\ket{0}\otimes\ket{j_{n-2}}+e^{\pi i j_{n-1}}e^{\frac{2\pi i j_{n-2}}{2^2}}\ket{1}\otimes\ket{j_{n-2}}\right) \otimes \frac{1}{\sqrt{2}}\ket{j_{n-3}\hdots j_0}\\
       &{} = \left(\ket{0}+e^{2\pi i \left(\frac{j_{n-1}}{2^1}+\frac{j_{n-2}}{2^2}\right)}\ket{1}\right) \otimes \frac{1}{\sqrt{2}}\ket{j_{n-2}\hdots j_0}\\
    \end{align*}
    \item In an identical way, it follows that the state at point 4 is
    \begin{align*}
         \left(\ket{0}+e^{2\pi i \left(\frac{j_{n-1}}{2^1}+\frac{j_{n-2}}{2^2}+\frac{j_{n-3}}{2^3}\right)}\ket{1}\right) \otimes \frac{1}{\sqrt{2}}\ket{j_{n-2}\hdots j_0}
    \end{align*}
    \item In this way, the topmost qubits picks up a phase with every controlled rotation upto point 5. At this point the state becomes
    \begin{align*}
        &{}\left(\ket{0}+e^{2\pi i \sum_{t=0}^{n-1}\frac{j_t}{2^{n-t}}}\ket{1}\right) \otimes \frac{1}{\sqrt{2}}\ket{j_{n-2}\hdots j_0}\\
        &{}=\left(\ket{0}+e^{2\pi i\frac{j}{2^n}}\ket{1}\right) \otimes \frac{1}{\sqrt{2}}\ket{j_{n-2}\hdots j_0}
    \end{align*}
    where we have used Eq.~\ref{EqBinaryExpansion}.
    From now on, the topmost qubit remains unchanged.
    \item In a similar manner, beyond point 6, the the next qubit (the one below the topmost qubit) remains unchanged. At this point, the state of the system is
    \begin{align*}
        \left(\ket{0}+e^{2\pi i\frac{j}{2^n}}\ket{1}\right) \otimes \left(\ket{0}+e^{2\pi i\frac{j}{2^{n-1}}}\ket{1}\right) \otimes \frac{1}{\sqrt{2^2}}\ket{j_{n-2}\hdots j_0}
    \end{align*}
\item Finally, at point 7, the state is
\begin{align*}
    \frac{1}{\sqrt{2^n}} \left(\ket{0}+e^{2\pi i\frac{j}{2^n}}\ket{1}\right) \otimes \left(\ket{0}+e^{2\pi i\frac{j}{2^{n-1}}}\ket{1}\right) \otimes \hdots \otimes \left(\ket{0} + e^{\frac{2\pi ij}{2}}\ket{1}\right)
\end{align*}
\item If we could record this output in the reverse order (i.e., topmost qubit first), we would obtain the expression on the RHS of Eq.~\ref{QFT_main}.
\end{enumerate}

What we have done here is to show that if the input of the circuit (Fig.~\ref{QFT_circuit}) is the computational basis vector $\ket{j}$, then the output, in the reverse order of qubits, is the state on the RHS of Eq.~\ref{QFT_main}. If this state is written as a linear combination of the computational basis vectors, then one recovers the expression on the RHS of Eq.~\ref{QFT_2} such that the coefficients of expansion denote the discreet Fourier transform of a sequence of numbers given by $\{\delta_{1,j}, \delta_{2,j}, \hdots, \delta_{j,j},\hdots,\delta_{N,j}\}$ (which are essentially the coefficients of expansion of $\ket{j}$ with respect to the computational basis).

How can we go about finding the QFT of a generic state $\ket{X}=\sum_{j=0}^{2^n-1} f(j)\ket{j}$? 

Naturally,
\begin{align*}\label{QFT_generic}
    \hat{U}_{\mathrm{QFT}}\ket{X} &{}= \sum_{j=0}^{2^n-1} f(j) \hat{U}_{\mathrm{QFT}} \ket{j}\\
    &{}=\frac{1}{\sqrt{N}} \sum_{j=0}^{N-1} f(j) \left(\sum_{k=0}^{N-1}e^{2\pi ij\frac{k}{N}}\ket{k}\right)\\
    &{} = \frac{1}{\sqrt{N}} \sum_{k=0}^{N-1} \left( \sum_{j=0}^{N-1} f(j) e^{2\pi ij\frac{k}{N}}\right) \ket{k}\\
    &{} = \frac{1}{\sqrt{N}} \sum_{k=0}^{N-1} \tilde{f}(k)\ket{k},\numberthis
\end{align*}
where, in the second line we have used Eq.~\ref{QFT_2} and in the fourth line we have used Eq.~\ref{Fourier_tilde_expansion}. Therefore, as expected from the linearity of the QFT operator, if we use a generic state $\ket{X}$ as the input for the circuit of Fig.~\ref{QFT_circuit}, the output, read in the reverse order, will be its QFT.

If we want the discrete Fourier transform of the sequence $\{f(0),f(1),\hdots,f(N-1)\}$, then, first of all, we have to prepare the input state as $\sum_{j=0}^{N-1}f(j)\ket{j}$ (unfortunately, this is not always possible in an efficient manner). Then we will feed this into the circuit of Fig.~\ref{QFT_circuit} and measure the output. If we repeat the entire process for say, $\tau$ number of times, then at different iterations, the measurement will collapse the final state to different vectors of the computational basis.
%
If the number of collapses to the state $\ket{k}$, recorded in the reverse order, is $\tau_k$, then we can conclude that $\tilde{f}(k)=\left(\frac{\tau_k}{\tau}\right)^{0.5}$.

Notably, excluding the number of operations required for the preparation of the initial state, the number of operations required in the circuit (Fig.~\ref{QFT_circuit}) is $n + (n-1) + \hdots + 1=\frac{n(n+1)}{2}$, which scales polynomially with respect to the number of qubits.
\end{document}
